<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stopwatch</title>
<style>
  /* exact filename you provided earlier */
  @font-face {
    font-family: "Science Gothic";
    src: url("fonts/ScienceGothic[CTRS,slnt,wdth,wght].ttf") format("truetype-variations"),
         url("fonts/ScienceGothic[CTRS,slnt,wdth,wght].ttf") format("truetype");
    font-weight: 100 900;
    font-style: normal;
    font-display: swap;
  }

  :root{
    --bg:#000;
    --fg:#fff;
    --panel: rgba(255,255,255,0.08);
    --muted: rgba(255,255,255,0.75);
  }

  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font-family: "Science Gothic", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    text-transform: uppercase;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    user-select:none;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
  }

  /* main time - tight MW2 style */
  .time {
    font-variation-settings: "wght" 350, "wdth" 120;
    font-feature-settings: "tnum" 1, "lnum" 1;
    font-variant-numeric: tabular-nums;
    font-size: clamp(72px, 13vw, 160px);
    line-height:0.9;
    letter-spacing: -0.06em; /* tighter like killcam */
    text-align:center;
    margin:0;
  }

  .hint {
    margin-top:8px;
    font-size:12px;               /* smaller like you wanted */
    color:var(--muted);
    letter-spacing:0.12em;
    text-align:center;
  }

  /* reset box top-right */
  .reset-box{
    position:fixed;
    top:20px;
    right:20px;
    background:var(--panel);
    border-radius:12px;
    padding:10px 14px;
    font-size:14px;
    font-weight:600;
    letter-spacing:0.04em;
    text-transform:uppercase;
    opacity:0;
    transition: opacity .35s ease, transform .25s ease;
    pointer-events:none;
  }
  .reset-box.show{ opacity:1; }

  /* settings icon bottom-right */
  .settings-btn {
    position:fixed;
    bottom:16px;
    right:16px;
    width:44px;
    height:44px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:var(--panel);
    border-radius:999px;
    cursor:pointer;
    z-index:120;
    font-size:20px;
  }

  /* slide-up menu */
  .settings-menu {
    position:fixed;
    right:16px;
    bottom:70px;
    width:170px;
    border-radius:12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    backdrop-filter: blur(6px);
    padding:8px;
    box-sizing:border-box;
    transform: translateY(18px);
    opacity:0;
    transition: transform .22s ease, opacity .22s ease;
    z-index:110;
  }
  .settings-menu.open {
    transform: translateY(0);
    opacity:1;
  }

  .settings-option {
    display:flex;
    align-items:center;
    gap:10px;
    padding:8px 6px;
    cursor:pointer;
    user-select:none;
  }
  .settings-option input { accent-color:#fff; }
  .settings-option label { font-size:13px; }

  ::selection { background: rgba(255,255,255,0.06); }
</style>
</head>
<body>
  <div id="resetBox" class="reset-box">RESETTING IN 3</div>

  <div class="wrap">
    <div id="timeDisplay" class="time">00:00.0</div>
    <div class="hint" id="hint">PRESS SPACE TO START/STOP | PRESS AND HOLD R TO RESET</div>
  </div>

  <div id="settingsBtn" class="settings-btn" title="Settings">⚙️</div>

  <div id="settingsMenu" class="settings-menu" aria-hidden="true">
    <div class="settings-option"><input type="radio" name="dec" id="d1" value="1" checked><label for="d1">1 DECIMAL</label></div>
    <div class="settings-option"><input type="radio" name="dec" id="d2" value="2"><label for="d2">2 DECIMALS</label></div>
    <div class="settings-option"><input type="radio" name="dec" id="d3" value="3"><label for="d3">3 DECIMALS</label></div>
  </div>

<script>
(() => {
  // elements
  const timeDisplay = document.getElementById('timeDisplay');
  const resetBox = document.getElementById('resetBox');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsMenu = document.getElementById('settingsMenu');
  const radios = document.querySelectorAll('input[name="dec"]');

  // state
  let running = false;
  let frozen = false;
  let startTs = 0;      // performance.now() when timer started
  let elapsedMs = 0;    // accumulated milliseconds when stopped
  let raf = null;
  let decimals = 1;

  // reset hold
  const RESET_SECONDS = 3;
  let resetInterval = null;
  let resetRemaining = RESET_SECONDS;

  // space handling debounce for taps vs holds
  let spaceHoldTimer = null;
  const HOLD_THRESHOLD = 250; // ms to consider hold (freeze) vs tap
  let spaceIsHeld = false;

  // formatting
  function formatTime(ms) {
    const totalMs = Math.max(0, Math.floor(ms));
    const totalSeconds = Math.floor(totalMs / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const fractionMs = totalMs % 1000;
    const scaled = Math.floor(fractionMs / Math.pow(10, 3 - decimals));
    const fracStr = String(scaled).padStart(decimals, '0');
    return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${fracStr}`;
  }

  function currentElapsed() {
    if (running && !frozen) {
      return elapsedMs + (performance.now() - startTs);
    }
    return elapsedMs;
  }

  // render loop
  function renderOnce() {
    timeDisplay.textContent = formatTime(currentElapsed());
  }
  function renderLoop() {
    renderOnce();
    raf = requestAnimationFrame(renderLoop);
  }
  function ensureRAF() {
    if (!raf) raf = requestAnimationFrame(renderLoop);
  }
  function stopRAF() {
    if (raf) { cancelAnimationFrame(raf); raf = null; }
  }

  // timer control
  function startTimer() {
    if (running) return;
    running = true;
    startTs = performance.now();
    ensureRAF();
  }
  function stopTimer() {
    if (!running) return;
    elapsedMs += performance.now() - startTs;
    running = false;
    stopRAF();
    renderOnce(); // freeze instantly without flicker
  }
  function resetNow() {
    running = false;
    frozen = false;
    elapsedMs = 0;
    stopRAF();
    renderOnce();
    // show reset notice briefly and hide
    resetBox.textContent = 'RESET!';
    setTimeout(()=> resetBox.classList.remove('show'), 400);
  }

  // reset hold logic (top-right box)
  function startResetCountdown() {
    if (resetInterval) return;
    resetRemaining = RESET_SECONDS;
    resetBox.textContent = `RESETTING IN ${resetRemaining}`;
    resetBox.classList.add('show');
    ensureRAF();
    resetInterval = setInterval(()=>{
      resetRemaining--;
      if (resetRemaining > 0) {
        resetBox.textContent = `RESETTING IN ${resetRemaining}`;
      } else {
        clearInterval(resetInterval);
        resetInterval = null;
        resetNow();
      }
    }, 1000);
  }
  function cancelResetCountdown(){
    if (resetInterval) {
      clearInterval(resetInterval);
      resetInterval = null;
    }
    resetBox.classList.remove('show');
  }

  // keyboard handlers: space tap toggles start/stop instantly,
  // holding space will freeze while held (if timer already running).
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      if (spaceIsHeld) return; // ignore repeats
      spaceIsHeld = true;

      // start a hold timer. if it reaches threshold and timer is running -> freeze
      spaceHoldTimer = setTimeout(() => {
        if (running) {
          frozen = true;           // freeze while held
        }
        // keep indicator that it's a hold
        spaceHoldTimer = null;
      }, HOLD_THRESHOLD);

      // immediate tap behavior: if timer NOT running, start it immediately on keydown
      // (so quick taps start without waiting for keyup)
      if (!running) {
        startTimer();
      }
      // if running and user pressed, we wait to see if it's a hold (freeze) or a quick tap release (stop)
      // do nothing else here — keyup will handle quick tap toggling.
    }

    else if (e.code === 'KeyR') {
      e.preventDefault();
      startResetCountdown();
    }
  }, {passive:false});

  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      // if holdTimer still pending -> it's a quick tap release
      if (spaceHoldTimer) {
        clearTimeout(spaceHoldTimer);
        spaceHoldTimer = null;
        // quick tap release behavior:
        // if we started the timer on keydown because it wasn't running, we want keyup to do nothing (already started)
        // otherwise toggle stop if timer was running and not frozen
        if (running && !frozen) {
          // this is a quick tap to stop
          stopTimer();
        } else {
          // if frozen flag somehow not set but running false: start (defensive)
          // do nothing else
        }
      } else {
        // if holdTimer expired and set frozen=true earlier, unfreeze on keyup
        if (frozen) {
          frozen = false;
          // reset startTs so continuation is smooth
          startTs = performance.now();
        }
      }
      spaceIsHeld = false;
    }

    else if (e.code === 'KeyR') {
      cancelResetCountdown();
    }
  });

  // touch: tap = toggle, longpress -> start reset countdown
  let touchHoldT = null;
  window.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    // start timer on short tap start if not running
    if (!running) startTimer();

    touchHoldT = setTimeout(()=> {
      // start reset countdown if held
      startResetCountdown();
      touchHoldT = null;
    }, 500);
  }, {passive:false});

  window.addEventListener('touchend', (ev) => {
    ev.preventDefault();
    if (touchHoldT) {
      // short tap end - toggle stop if running (and not frozen)
      clearTimeout(touchHoldT);
      touchHoldT = null;
      if (running && !frozen) {
        stopTimer();
      }
    } else {
      // long press ended - cancel reset (if running)
      cancelResetCountdown();
    }
  }, {passive:false});

  // settings UI
  settingsBtn.addEventListener('click', (ev) => {
    ev.stopPropagation();
    settingsMenu.classList.toggle('open');
  });
  window.addEventListener('click', (ev) => {
    if (!settingsMenu.contains(ev.target) && !settingsBtn.contains(ev.target)) settingsMenu.classList.remove('open');
  });

  radios.forEach(r => r.addEventListener('change', (ev) => {
    decimals = parseInt(ev.target.value, 10);
    renderOnce();
  }));

  // initial render
  renderOnce();
})();
</script>
</body>
</html>
